### 1.请你说说python传参传引用

​    python 的函数传递方式使用的是引用的方式，就是将实参的地址传递给形参，执行期间实参和形参公用相同的内存单元，被调用的函数对于实形参的任何操作都等同于对实参的操作，所以实参会随着形参的变化而变化

### 2.python 的僵尸进程

​    僵尸进程：子进程结束后父进程并未结束，此时子进程占用的资源（打开的文件，占用的内存）会被cpu回收，但是子进程的信息（进程号PID，运行时间，退出状态）会被保留，子进程变成僵尸进程
​    僵尸进程的危害：当僵尸进程大量堆积的时候会占用大量的PID号,但是进程号有限，大量的堆积PID号会影响新的子进程生成

### 3.python 重载

​    python没有重载，python本身传参就是重载

### 4.python 的上下文管理器

​    with open as f: 在内部已经实现了
​        1.__enter__
​        2.__exit__
​        这两个方法实现上下文管理器
​    上下文管理器的优点：
​        1.提高代码复用率
​        2.提高代码优雅度
​        3.提升代码可读性

### 5.python2和python3的区别

​    1.python3中的print 使用（）   
​    2.python2中使用ascii编码，python3中使用utf-8编码
​    3.pytohn2中使用raw_input() python3中使用input()
​    4.python2中rang(1,10)返回列表 python3中返回迭代器

### 6.python支持五种基本数据类型

​    可变：
​        Number(数字)
​            int
​            float
​            bool
​            complex
​        String(字符串)
​        List(列表)
​        set(集合)
​    不可变：
​        Tuple(元组)
​        Dictionary(字典)

7. DDL   数据库定义语言

8. DML   数据库操纵语言

9. DQL   数据库控制语言 授权 角色控制等

10. DCL   事务控制语言

11. having子句即可包含聚合函数作用的字段也可包括普通的标量字段

12. having子句必须于group by 子句同时使用，不能单独使用

13. ### 常见的反爬虫机制

    UA
    设置IP访问频率，如果超过一定频率，弹出验证码
    通过并发识别爬虫 有些爬虫的并发是很高的，统计并发最高的IP，加入黑名单（或者直接封掉爬虫IP所在C段）
    请求的时间窗口过滤统计 
    限制单个ip/api token的访问量
    识别出合法爬虫 对http头agent进行验证，是否标记为、百度的spider，严格一点的话应该判别来源IP是否为、baidu的爬虫IP，这些IP在网上都可以找到。校验出来IP不在白名单就可以阻止访问内容。
    蜜罐资源 爬虫解析离不开正则匹配，适当在页面添加一些正常浏览器浏览访问不到的资源，一旦有ip访问，过滤下头部是不是搜素引擎的蜘蛛，不是就可以直接封了。比如说隐式链接。

14. ### 破解反爬虫机制的几种方法

    设置下载延迟
    禁止Cookie
    使用user agent池
    使用IP池
    分布式爬取
    模拟登录—浏览器登录的爬取

15. ### 深拷贝与浅拷贝

    深拷贝相当于在本地拷贝了一个副本 副本的变化不会影响到源文件中的数据

    浅拷贝相当于是内存指针调用 副本变化会改变原数据

16. ### python 如何实现多线程

    线程是一个轻量级的进程，多线程允许依次执行多个线程

    GIL锁（全局解释锁）确保一次执行单个线程，一个线程保存GIL并在将其传递给下一个线程之前执行一些操作，这样就会产生并行执行的错觉，但是实际上，只是线程轮流在CPU上执行

17. ### 如何在python中管理内存

    python中使用一个私有堆内存空间来防止所有的对象和数据结构，我们无法直接访问它。由解释器来管理它。不过使用一些核心的API我们可以访问一些Python内存管理工具控制内存的分配

18. ### 解释python中的help()和dir()

    help()函数返回帮助文档和参数说明

    dir()函数返回对象中所有的成员（任何类型）

19. ### 当退出python时是否释放所有内存分配

    否，具有对象循环引用或者全局命名空间引用的变量，在python退出时往往不会被释放

20. 猴子补丁

    在运行时动态的修改类和模块

21. ### *args和**kwargs的区别

    *args传递元组/列表

    **kwargs传递字典

22. ### 计算文件中的大写字母树

    .isupper（）

23. ### 负索引

    负索引从右边开始检索

24. ### 如何随机打乱列表中的元素，要求不引用额外的内存空间

    ![image-20210927154528892](C:/Users/JHC/AppData/Roaming/Typora/typora-user-images/image-20210927154528892.png)

25. ### join 和 split的区别

    ![image-20210927154917357](C:\Users\JHC\AppData\Roaming\Typora\typora-user-images\image-20210927154917357.png)

26. ### 删除字符串多余空格![image-20210927155617877](C:\Users\JHC\AppData\Roaming\Typora\typora-user-images\image-20210927155617877.png)

27. ### 字符串大小写转换

    isupper()	检查是否时大写

    islower()	检查是否时小写

    istitle()	检查是否是标题格式

    @  $ 这样的符号既满足大写又满足小写

    ![image-20210927155812275](C:\Users\JHC\AppData\Roaming\Typora\typora-user-images\image-20210927155812275.png)

![image-20210927160034241](C:\Users\JHC\AppData\Roaming\Typora\typora-user-images\image-20210927160034241.png)

28. ### python 中的闭包

    如果一个内部函数里，对外界作用域（但不是在全局作用域）的变量进行引用，那么内部函数就是一个闭包

29. 位运算

    和 & 同1为1 其他为0

    或 | 遇1为1

    异或 ^ 同为0，不同为1

    取反 ~  原码 反码 补码 

    ​	最左边 符号位 1为负数，0为正数

    ​	正数 原码=反码=补码

    ​	负数 原码=符号位不变，其他按位取反=反码+1

30. ### 元组的解封装

    ![image-20210927165155741](C:\Users\JHC\AppData\Roaming\Typora\typora-user-images\image-20210927165155741.png)



31. ###  定义多个变量并且赋值

    (1) a,b,c=1,2,3

    (2) a=b=c=3

32. ### 进程和线程的区别

    进程是资源分配的基本单位

    线程是程序中执行的最小单位

    进程有自己独立的内存空间，没启动一次进程，系统就会为它分配地址空间，建立数据表来维护代码段，堆栈段和数据段

    线程是共享进程中的数据，使用相同的地址空间，因此cup切换一个线程花费的远比进程要小很多，同时创建一个线程的开销也比进程小很多

    进程：from multiprocessing import pool

    线程：threading.Thread

33. ### 协程

    子程序切换不是线程切换，而是由程序自身控制

    没有线程切换的开销，和多线程比，线程数量越多，携程的性能优势就越明显

    不需要多线程的锁机制，因为只有一个线程，也不循在同时写变量的冲突，在协程中控制共享资源不加锁

34. ### 垃圾回收机制

    引用计数：创建一次，调用一次

    分代技术：python中默认定义了三代对象集合，索引越大，对象存活时间越长；python中使用了某些启发式算法来加速垃圾回收（越晚创建的对象越早被回收）

    引用循环：垃圾回收器定时寻找这个循环

35. ### 迭代器、生成器

    迭代器是一个可以记住遍历位置的对象，迭代器只能往前，不会后退

    迭代器基本方法：iter()  next()

    字符串，元组，列表 对象都可用于创建迭代器

    

    生成器 yield()

    生成器是一个返回迭代器的函数，只能用于迭代操作，简单理解 生成器就是一个迭代器 在调用生成器过程中，每次遇到yield()会暂停并且保存当前所有的运行信息，返回yield的值，并且在下一次执行next()时从当前位置继续执行 

    调用一个生成器对象，返回一个迭代器对象

36. read 、readline 、readlines 

    read 读取整个文件

    readline 读取下一行，使用生成器方法

    readlines 读取整个文件到一个迭代器以供我们遍历

    

    











